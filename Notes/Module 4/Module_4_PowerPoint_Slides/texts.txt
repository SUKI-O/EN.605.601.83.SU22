In this lecture we’ll define requirements engineering. Requirements Engineering Systems & Requirements Engineering Assuming the system level requirements for a product have been allocated to the various system components, we are ready to discuss requirements engineering...more specifically the requirements that the software components of a system will be responsible for.


Here‘s a few definitions of requirements engineering...and they‘re quite consistent with one another.

So why is the term engineering used here? Are there scientific principles and physics that are applied in the engineering of software requirements? Truthfully...and in practice...no. The word engineering is used as a way of emphasizing the use of systematic and repeatable techniques that help to ensure the completeness, correctness, consistency, and continued relevance of software requirements for a software product.

Requirements engineering is not always called that in practice. It’s often called requirements definition or requirements analysis. But, limiting it to requirements definition or requirements analysis leaves out an important keyword in both of the above definitions…and that keyword is maintenance.

Requirements can and will change during the course of a project, and maintaining requirements means to keep up with and manage those changes. Recall that in our discussion of project management one of the umbrella processes was requirements management…and it is as part of the requirements management process that the maintenance typically takes place.

Also…using the term engineering to emphasize systematic and repeatable activities is very important, since, for many organizations, the activities performed during the requirements phase of a project tend to be ad hoc.

Since this is a course on software engineering…we’re going to support and emphasize activities that are, in fact, systematic and repeatable, in our discussion of the requirements phase. So…let’s get started. What’s Requirements Engineering? “Requirements engineering consists of all the activities involved in discovering, documenting, and maintaining a set of software requirements.” Adapted from: I. Somerville, P. Sawyer, Requirements Engineering: A Good Practice Guide, Wiley, 1997. “Requirements engineering  refers to the process of defining, documenting, and maintaining software requirements and to the subfield of software engineering concerned with this process.” Wikipedia Now, the system-level requirements that are allocated to software are stated at a very high level...usually with a single sentence. So...they are not yet specified at a level of detail that would be sufficient to begin system design from...and...they may need to be decomposed into more specific requirements...or may spawn additional requirements that are necessary to correctly and completely specify the responsibilities of the software to be developed. 

So...the initial activities of requirements engineering...which I‘ll refer to as the requirements definition phase...will need to be performed. Requirements Allocated to Software  In this lecture we’ll discuss some basic concepts in systems engineering . Systems Engineering Systems & Requirements Engineering While the focus of this course is on software engineering, I want to take a little time to talk about putting software engineering into the larger context of systems engineering. So...let me start by discussing the term system.

What‘s a system anyway? Well...there are many definitions of the term system, even within the systems engineering profession. 

Let me start with a dictionary definition. [*] Webster‘s Collegiate Dictionary defines a system as a regularly interacting or interdependent group of items that form a unified whole. [*] The International Council on Systems Engineering defines a system as a homogeneous entity that exhibits pre-defined behavior and which is composed of heterogeneous parts that do not individually exhibit that behavior...and which is an integrated configuration of components and/or subsystems. That‘s kind of a mouthful. And there are quite a few more definitions. The IEEE has one, the International Standards Organization...ISO...has one, and many other organizations. There are things I like in both of these definitions...the concept of a unified whole, the concept of components and subsystems. The definition I like the best, since it‘s very easy to remember, is this one. A set of interrelated components working together toward some common objectives.

There are lots of different kinds of systems that exist in the world. There‘s the solar system, the number system, ecological systems, weapons systems, and everyday products like automobiles that are, in fact, systems.

 What’s a System? “A regularly interacting or interdependent group of items forming a unified whole.” Webster’s Collegiate Dictionary “A homogeneous entity that exhibits pre-defined behavior and is composed of heterogeneous parts that do not individually exhibit that behavior…an integrated configuration of components and/or subsystems.” Adapted from INCOSE Systems Engineering Handbook, INCOSE, 2007 “A set of interrelated components working together toward some common objective.” A. Kossiakoff, W. Sweet, S. Seymour, S. Beimer, Systems Engineering Principles & Practices, 2nd Edition, Wiley-Blackwell, 2007 Now that we‘ve established a definition or two about what a system is, what then is software engineering? 

According to Wikipedia, it‘s an interdisciplinary field of engineering that focuses on how to design and manage complex systems. And, according to the late Alexander Kossiakoff, a former director of the Johns Hopkins Applied Physics Laboratory, its purpose is to guide the engineering of complex systems.

Systems engineering typically requires the collaboration of many different types of disciplines, such as electrical engineering, mechanical engineering, perhaps physics or other scientific disciplines, and also software engineering. 

Note that the word complex is used in both of these definitions. According to Kossiakoff, complexity restricts systems engineering to systems in which the elements are diverse and have intricate relationships with one another. What he meant by that is systems engineering, as a discipline, is not likely to be applied to smaller, simpler systems.

 What’s Systems Engineering? “An interdisciplinary field of engineering that focuses on how to design and manage complex systems.” Wikipedia “The function of systems engineering is to guide the engineering of complex systems.” A. Kossiakoff, W. Sweet, S. Seymour, S. Beimer, Systems Engineering Principles & Practices, 2nd Edition, Wiley-Blackwell, 2007 Another characteristic of systems is that they contain components that work together to contribute to the system‘s overall functionality. These components are often called subsystems.

As a real and concrete system example, let‘s take an automobile. The automobile itself is a system, with well-defined behavior. It consists of numerous subsystems, some of which are identified in this schematic. There‘s a powertrain system, a safety control system, and so forth. And quite a few more, like a fuel control system, a brake control system...I could go on and on, but I‘m hoping you see my point. Each of the automobile‘s subsystems are designed to provide well-defined behavior that contributes to the overall functioning and behavior of the entire automobile. Some of these subsystems may be relatively independent, and some might be quite interdependent on other subsystems.

At this point, you might be wondering how all this relates to software engineering. It relates directly to software engineering. If you drive a reasonably modern car, you are most likely aware that many features of your car are controlled, at least in part, by software.

Your car‘s brake control system, for example, may include sensors that monitor wheel speed driving angle and send signals to an onboard computer to automatically adjust braking and engine power to ensure that you always remain in control of the vehicle. 

When automobiles are designed, some of the decisions that are made in the systems engineering process is which subsystems will be responsible for various functions, which functions will be satisfied by hardware components, and which will be satisfied by software.

So...before any software engineering takes place...system responsibilities...or requirements...must be allocated to the software components that make up the system and subsystem elements. Systems & Subsystems Here‘s a piece of a systems engineering life cycle. The first two phases in this life cycle consist of system requirements analysis and system design. System requirements analysis determines the requirements for the overall system. Some of these requirements will be fulfilled by hardware, some by software and some by both...as an example, software may be embedded in firmware for certain functions.

A step within these phases, sometimes called functional analysis or functional allocation, will allocate the system functionality to the system‘s hardware components and its software components. Then, the software engineering process begins...as indicated by the upper part of the diagram...as does the hardware engineering process...indicated in the lower portion of the diagram. Then, the hardware components are integrated, tested, and so forth.

So...what I wanted to accomplish here is how software engineering fits into the overall systems engineering process. Now, there can be quite a few variations on the diagram I used here. For example, this diagram is showing a step in which hardware is actually fabricated. For some types of systems, component parts might just be purchased and interfaced to the software.

In the next lecture, I‘ll discuss some of the criteria that might be used to allocate system requirements to software. Allocating Requirements In this lecture we’ll discuss allocating required system functionality to different system components. Allocating Requirements Systems & Requirements Engineering Before we allocate requirements to system components it is important to identify the various subsystems and components of the system. For our purposes, we‘ll focus on systems that contain hardware, software people and processes.

Hardware can consist of one or more computers, peripheral devices, storage devices, and perhaps special devices such as sensors or measuring devices that could be responsible for sensing changes in environmental variables or reporting measurements. Some applications, like embedded applications, may also require firmware to perform certain functions.

Software could also be decomposed, if necessary, into components such as application software, operating system software, and databases. 

Processes could also be responsible for performing needed functionality, either by modifying existing processes or developing new business processes.  Sample System Components Once the subsystems and components have been identified, system functions must be allocated to them. In systems engineering this is called functional allocation or functional analysis.

How various functions are allocated is dependent upon each system and its associated parameters, and is typically an exercise in trade-off analysis. Things called drivers, that focus on particular system characteristics, are often used to help make allocation decisions and tradeoffs among the drivers. A dozen commonly used drivers are illustrated here...and I‘ll elaborate on a few of them.

Sometimes the functionality of the subsystems and components make them clear candidates for allocating the overall system functions. In situations where constant monitoring or measurements are required, for example, or where a high level of precision is required, are typically good candidates for allocating to hardware components. 

Functionality that requires interfacing to humans, software, or hardware are also considered during allocation. Hardware components typically dictate the interface specifics...either for software interfaces or human interfaces; human interfaces, particularly those that may need to be changed over time, are typically allocated to software.

Physical constraints are another driver. In some projects there may be weight, space, or temperature constraints.

Cost and schedule tradeoffs are obvious drivers that are usually applicable on most every project.

 Sample Allocation Drivers There are a number of techniques that can be used to help make allocation tradeoff decisions. Most of these techniques use a type of analysis called multi-criteria decision analysis (MCDA). Multi-criteria decision analysis helps us to make decisions about alternatives based on multiple criteria, in which some of the criteria may conflict with one another. Multi-criteria decision analysis is used in a number of engineering disciplines, including systems engineering.

Most multi-criteria decision analysis techniques use some kind of matrix...called a decision matrix. A commonly used form of multi-criteria decision analysis uses a decision matrix called the Pugh Matrix...named after Stuart Pugh, who was a professor at a university in Scotland. 

A basic Pugh Matrix is illustrated here...and there are numerous variations. A Pugh Matrix is used to evaluate a number of alternatives compared to some baseline. The baseline is typically an existing product or solution.

The rows of the matrix list the criteria that the decision will be based on. The criteria will be chosen based upon what‘s important in a specifc problem. The columns of the matrix contain the alternatives that will be evaluated. There‘s also a column for the current solution.

To illustrate the technique, let‘s take an example of replacing an existing system with one of three alternate systems. Then, we‘ll see how we can use the techique to allocate system requirements. So...in this example, we‘re going to evaluate the three alternatives with respect to four decision criteria that we think are the most important. For this example, let‘s assume the criteria are cost, schedule, performance, and reliability.

Our baseline is the current system, so we give it scores of zero. Then, we assess alternative 1 with respect to criteria 1. Is it better, the same, or worse than the baseline? If it‘s better, we give it a score of +1, if it‘s the same we give it a score of 0, and if it‘s worse we give it a score of -1. For our example, let‘s assume it‘s better...so we give it a +1. We then assess and score the remaining three criteria. Let‘s assume alternative one is the same for the second criteria, worse for the third criteria, and better for the fourth criteria.

We would then assess and score the second and third alternatives in a similar manner.

Then...we add up the scores in each column to get an overall total. In this case, the best choice is alternative three, with a total score of plus 3. It‘s also common to sum the positives, negatives, and neutrals, so that more insight into the pros and cons of each alternative can be visualized. This technique is useful because it helps us to make more objective and rational decisions.


 Evaluating Allocation Tradeoffs Pugh Decision Matrix There are several variations on the scoring method. One variation is to weight the criteria according to importance and then multiply the alternatives by the weights. 

In this example will use a set of weights that range from 1 to 5. let‘s assume that criteria one is given an importance rate of two, and that criteria two is considered twice as important...so we‘ll give it a weight of 4. Criteria three is somewhere between the first two criteria, so it gets a weight of 3. And, criteria four is the most important, so it gets a weight of 5.

Then, the +1, 0, and -1 scores for each of the alternatives are multiplied by the corresponding weights...so...the scores for the first criteria are multiplied by 2, the scores for the second criteria are multiplied by 4, and so forth.

Yet a third scoring variation is to expand the +1, 0, -1 scoring system to a two point system...where +2 would correspond to much better than the baseline, +1 would correspond to better than the baseline, and so forth. Evaluating Allocation Tradeoffs Weighted Pugh Decision Matrix Now...how does one use this decision analysis technique to allocate system functionality to subsystems or components? There‘s a couple of ways this could be done, but the most straightforward way is to take each system function and construct a Pugh Matrix for it. The rows of the matrix correspond to the important drivers, and the columns correspond to the subsystem that the function is allocated to. Allocating System Functions System Function X At this point we‘ve discussed allocation of system level requirements to different system components...and we will assume that the appropriate system requirements have been allocated to software. So, going forward, we will leave the topic of systems engineering and focus on software engineering [*]...starting with software requirements. Requirements Allocated to Software  In this lecture we’ll discuss the key activities in a requirements definition process and also discuss the primary requirements work products. Activities & Work Products Requirements Definition This input/output model shows the basic inputs, tasks, and work products associated with a requirements definition process.

It is in this process that analysts will identify key stakeholder groups, evaluate the system boundary, and elicit stakeholder needs to identify the project’s functional and non-functional requirements. Requirements may also be prioritized and validated as part of this work, and may be packaged into delivery cycles if an iterative or incremental project life cycle model is being followed.
 


Major deliverable work products produced in this activity typically include a Vision Document, a use case model…if the project is using a use-case driven approach…or a functional requirements specification document if use cases are not being used, and a supplementary specification document.

Depending on the organization, there may be additional work products produced, and the information that is contained in what we are calling a Vision Document and a Supplementary Spec may be packaged into documents with different names…but I’m going to use these two documents because they are a very effective way to capture and organize essential information.

It’s worth noting here that if our project is using an object-oriented approach this model would represent the first step in object-oriented requirements analysis…and the work products listed here would represent the user view of requirements. These documents would make no mention of objects, but would serve as the input to the object-oriented requirements analysis step.
 Requirements Definition Let’s take a look at the kinds of information that go into the Vision Document. A sample Vision Document template is illustrated here.

The Vision Document specifies the stakeholders’ view of the product to be developed. It is written in terms of the stakeholders’ key goals/needs and desired features. And, it provides the basis for eliciting and specifying the more detailed product requirements.

Some of the document’s components, like business opportunity and problem statement, are pretty obvious in their meanings. Some of the components, like market demographics, may not be applicable to every organization and project. This sample template was one that I helped to develop for a software vendor client…so market demographics was very relevant for them.

Section 3 in this document is extremely important. It contains a description of product stakeholders and their needs. Note that there are two types of stakeholders: end user stakeholders and non-user stakeholders. The user stakeholder components were included because our client realized that identification of the actual end-users of the software product is essential to developing a successful product. 

A relatively common industry problem that I see much more than I’d like to is failure to actually collaborate with end users during the requirements phase…and it almost always results in products that are lacking needed functionality.

 Sample Vision Document Introduction  	1.1	Purpose 	1.2	Scope 	1.3	Definitions, Acronyms & Abbreviations  Positioning  	2.1	Business Opportunity 	2.2	Problem Statement 	2.3	Product Position Statement  Stakeholder & User Descriptions  	3.1	Market Demographics 	3.2	Stakeholder Summary 	3.3	User Summary 	3.4	User Environment 	3.5	Stakeholder (non-user) Profiles 	3.6	User Profiles 	3.7	Key Stakeholder Goals/Needs 	3.8	User Goals/Needs  Product Overview Product Features 6.	Constraints 
Earlier in the course I talked about project stakeholders and how they contribute to more correct and complete requirements. In an earlier lecture I also defined a stakeholder as any entity that was directly or indirectly impacted by the project at hand.

Using this definition of the term stakeholder is extremely useful in helping a project team identify a more complete set of candidate stakeholders. There can be many types or categories of stakeholder for a project…and this diagram illustrates a sampling of that. I like to call this my layered or concentric ring model…and it can help in identifying a more complete set of stakeholders.
 
At the center is the system we’re gathering requirements for. My first layer of stakeholders is what I call direct stakeholders. These stakeholders are directly impacted by the product we are building, and they consist of, for example, end users, project sponsors, developers, testers, those that will have to support the system when it’s in production, and so forth. You can add more categories depending upon the specific organization and product. 
 
The next layer is the enterprise layer. This layer consists of stakeholders that may be indirectly impacted by the system. And the third layer consists of entities outside the organization. This might include service providers and regulators, as examples.
 
Some of my clients have used this model as a starting point…and then have added their own specifics. The important thing is to ensure that we identify the most complete stakeholder set possible for a project.
 Many Types Of Stakeholders 60 %   Direct Enterprise Outside World Many projects today are use-case-driven. By that I mean that use cases are used to document the project’s functional requirements. 
 
A use case is a different way of documenting functional requirements. It documents those requirements by essentially telling a story that contains related functions the system must perform, the order in which they are performed, and the user interactions that are involved.
 
This is a partial use case that describes some of the steps and interactions required to process a sale transaction in a point-of-sale system. If you read through the ten steps note that it kind of tells a story about what functions the system must perform when processing a sale. We’ll talk about use cases in more detail in a later lecture.
 
For now, it will suffice to know that one of the key work products produced in the requirements elicitation phase is a set of use cases that document the system’s functional requirements.
 Use Case Document Another important document that is produced during the requirements elicitation activity is a Supplementary Specification document. Here’s a template for one that I helped develop for a software vendor client.
 
Section one of this supplementary spec is essentially the same as the first section of the Vision Document. In cases where it is the same, common practice is just to point to that section in the Vision Document instead of regurgitating all the information.
 
Section two of the Supplementary Spec contains a section for documenting functional requirements that are documented in the traditional way. By “traditional way” I mean by not using use cases.
 
Section three of the spec contains a section for documenting business rules. The business rules could be global business rules, business rules referenced in use cases, or business rules referenced in section two.
 
The remaining sections of the spec are used to document a project’s non-functional requirements. Not all of these sections would be applicable for all projects, but they represent a pretty good list of possible non-functional requirements.
 Sample Supplementary Spec Introduction Functional Requirements 3.   Business Rules e.g. global rules or rules referenced in use cases or section 2 4.   Usability 5.   Reliability 6.   Performance 7.   Supportability 8.   Design Constraints 9.   Documentation & Help System Requirements 10. Purchased Components 12. User Interfaces 13. Hardware Interfaces 14. Software Interfaces 15. Communication Interfaces 16. Licensing Requirements 17. Legal, Copyright, Other Notices 18. Applicable Standards   		e.g., regulatory, internationalization In this lecture we’ll discuss the different types of requirements. Introduction to Requirements Requirements Definition 
In this lecture I’m going to talk about some very basic but very important things about requirements for software products, and I’m also going to share a few of my several decades of experiences regarding requirements.

I’d like to start off this lecture by asking you to think about what a requirement is. So…before I even get started, I’d like you to pause this lecture, take a minute or two to think about your answer, and write it down. When you’re finished, you may resume the lecture.

Before I tell you why I asked you to do that little exercise, I want to share some of my experiences with you. I’ve been working in the software engineering field for decades…and…I see organizations having the same problems getting good requirements today as I did 30 years ago. Exactly the same problems…and for exactly the same reasons. And it doesn’t matter what industry or sector of the economy I’ve worked with, or whether the organizations were large or small.
 
So…why have organizations had difficulty getting good requirements for such a long time? There are numerous reasons for this, but I’m going to focus only on one in this lecture: the lack of a common understanding of what a requirement is.
 
One of the key reasons that this problem has persisted for so long is very basic…but very important…and is almost always overlooked in organizations. Simply put, different stakeholders on a project have different beliefs about what a requirement is. In my requirements consulting projects I will often get a group of stakeholders together in a room and ask them to write down their definition of what a requirement is. Here’s a sample of some of the results I get. [*]

If I have a room full of 10 people, I will get 10 different definitions. If I have a room full of 20 people, I will get 20 different definitions. It never fails.
 
This is very problematic, because a person’s understanding of what a requirement is sets their expectations about things like what kinds of information needs to be gathered, what they think they are responsible for, what they think others are responsible for, and what they think the end result is supposed to be. The bottom line is that most projects start off with what I like to call unleveled expectations…and things just get worse from there as the project unfolds.

Doing what I call “leveling expectations” is the first step to getting better requirements. But…how do you do that? What’s a Requirement? One of the easiest ways to ensure that stakeholder expectations are leveled is to start out with a common definition of what a requirement is and to communicate that definition to key project stakeholders. In this context, key project stakeholders include analysts, customers, end users, developers, testers and managers.
 
Here’s a definition that I’ve adapted from an industry standard and which I recommend using:
A requirement is a capability that must be delivered by the system, or a condition that the system must satisfy.
 
I like this definition for several reasons…it’s simple, accurate, and easy to remember. And…it maps directly to the two major types of requirements associated with software development projects…namely, functional requirements and non-functional requirements.
 
Let’s take a look at some examples of each of these requirements types.
 What’s a Requirement?  A CAPABILITY that must be delivered by the system or a CONDITION that the system must satisfy.  CAPABILITY = Functional Requirement CONDITION = Non-Functional Requirement REQUIREMENT SOURCE: Adapted from IEEE Standard Glossary of Software Engineering Terminology, IEEE Standard 610.12-1990, IEEE Computer Society, 1990. Let’s start with functional requirements. A functional requirement is something the system must do…in other words, the behaviors the system must possess.
 
These could be behaviors like calculations, saving information, or displaying information, for example.
 
Functional requirements can be relatively simple…or…they can be quite complex.
 
Let’s take this example. I’ll provide some background information to add context. Let’s suppose our company sells widgets, and we are gathering requirements for an order entry system that will assist in processing sale transactions. Our sales department stakeholders need the system to calculate discounts on certain widget orders…so, calculate order discount is an example of a functional requirement…it’s something the system must do.
 
Now, the basic intent of the requirement is easy to understand…but the information required to document the requirement is relatively complex because of the business rules associated with the calculation. This is a pretty well-written requirement, but its business rules are kind of complex…so there is a risk that the rules could be incomplete, incorrect, or misunderstood by those who must develop software to implement it.
 
 Sample Functional Requirement Functional Requirement: Calculate Order Discount  A discount shall be applied to each order of widgets by computing a percentage of the total pre-tax order amount.  The discount shall depend upon the size of the order. If the order is for 1 to 100 widgets, the discount percentage shall be 0. If the order is for 101-300 widgets, the discount percentage shall be 5. If the order is for more than 300 widgets, the discount percentage shall be 8. The order discount amount shall be computed by multiplying the gross order amount by the discount percentage. Here’s a way to model a functional requirement that can be very helpful. A functional requirement can have 5 moving parts…inputs, outputs, statement of intended functionality, business rules, and possibly constraints.
 
Let me map the prior example to the model to illustrate how it works. I’ll start with the statement of intended functionality…which is basically the name of the requirement…calculate order discount. A functional requirement can also have inputs. In my example there is one input variable…an order quantity. A functional requirement can have outputs…in my example the output was the calculated order discount amount. And…a functional requirement can also have business rules. Business rules specify how to take the inputs and convert them to the outputs. In my example, most of the written text was the business rules.
 
A functional requirement may also have constraints. Constraints are criteria that have to be met in the performing of the function. There were no constraints in my example. In practice, constraints are things like a performance requirement that is mapped to a specific function…for example, a query must be performed within one second…or a constraint can be related to organization policy, regulatory policy, accuracy or precision.
 
Using a model like this one can help to ensure we gather complete and correct information for each functional requirement. Functional Requirement Model 60 % A non-functional requirement is a condition that the system must comply with. Several examples of non-functional requirement are illustrated here.
 
Note that these examples don’t specify behaviors of the system, but rather conditions or constraints that the system must comply with. Non-functional requirements provide important information to the system designers. For example, if the system must support up to 5,000 simultaneous users…versus a single user…the possible design alternatives are quite different.
 
Note also that these non-functional requirements are written as relatively simple shall statements. They don’t have all the moving parts that functional requirements do.
 Sample Non-Functional Requirements The system shall support up to 5,000 simultaneous users  The system shall operate 24/7 with no more than 5 percent downtime  The system shall operate on Windows 7 and Windows 8 platforms In this lecture we’ll introduce use cases and discuss how they are used in requirements definition. Use Cases vs. Traditional Requirements Requirements Definition So…what’s a use case? A use case is a way of documenting the functional requirements for a software product.

A use case describes a set of interactions between the product we are gathering requirements for, users of that product, and other systems the product will interact with. Use cases are used to describe the functional requirements for a software product.

I’ll use this sample use case to introduce the concept. First, let me give some background information to provide context. Let’s suppose we are gathering requirements for a point of sale software product that will be used by retail stores. One of the things such a system must be able to do is to support the processing of a sale transaction…and a use case like the one shown here might be written to describe the interactions and system functions associated with a sale transaction. 

The name of this use case is Process Sale. If you read through the ten steps, you can see that they describe what’s involved in processing a sale transaction. Now, this use case is only a partial use case. It’s incomplete in a number of ways. For example, the last step involves printing a receipt…but the data elements that must appear on the receipt are not specified yet. Also, the use case doesn’t describe the different interactions required if a customer pays by cash, credit card, or check. And it doesn’t specify what happens if a customer chooses to pay by credit card, but the charge can’t be authorized. It needs to deal with all of these things, and more, before it’s complete. But…it will suffice for our purposes right now.

I’d also like you to notice that a use case tells kind of a story about what needs to be done to process a sale. This “story” nature of use cases is very powerful.
 What’s a Use Case? Here‘s exactly the same process sale use case, but presented in a different format. I call this the two-column format. Things called actor actions are shown in the left-hand column, and system functions are shown in the right hand column. Don‘t worry about what an actor is at the moment. You‘ll learn about them shortly.

In practice, the single-column format shown at the beginning of the lecture is the most frequently used format. There‘s really no difference except for the visual appearance...the same information is presented. In this lecture, I‘m going to use the two-column format a lot, only because it makes better use of the video display real estate. Sample Use Case  Use Case Name: Process Sale Use cases are a different way of documenting requirements compared to the traditional way of documenting requirements. And...by traditional way I mean without using use cases.

Here‘s a skeleton of pieces of a traditional requirements document. One way such a document might be organized is to have a section for system inputs, a section for system outputs, one for calculations, and so forth. 

Now...let‘s assume for our sample point of sale product, that the requirements document is 70 pages in length. And...let‘s assume that the requirement that the system calculate total sale amount is on page 17 of that document, and the requirement for printing the receipt is on page 55 of that document. As a reader of that document, if I‘m interested in learning about all the functions required to process a sale transaction, I need to parse through the document and try to pick out all the related functional requirements...one is on page 17, one is on page 55, and the others will be scattered throughout the document. This presents quite a challenge. If I‘m a developer, or a tester, it‘s really important that I be able to find all the related functionality. If some required functionality was inadvertently left out of the document or not identified during the requirements process...it may be very hard to tell.

[*] Now, let‘s compare this to the use case approach. Take a look at every step in the use case that uses the word system. Each step that contains the word system represents at least one primitive level functional requirements. The system has to prompt the cashier, display running totals, calculate total sale amount, display a payment entry form, save the sale information and print a receipt. That‘s at least a half dozen primitive level functions...but they‘re all related to processing a sale transaction...and they‘re all documented right here in that single use case instead of being scattered throughout 70 pages of documentation.

This has many advantages. If there‘s a missing function it will be a lot easier to identify it. Also, the story nature of the use case presents readers of the use case with a vision of the future product. If I‘m a tester, the use case will form the basis of my test scenarios and identify all the functions that need to be exercised.

In an earlier lecture we learned that 80 percent of requirements defects are due to incomplete or incorrect requirements. We also learned about macro level requirements completeness...did we identify and document all the needed functionality. Use cases significantly help to ensure macro level completeness compared to the traditional approach. Use Cases vs. Traditional Documentation Traditional Requirements Document  … 3.0 Sales Calculations ... 3.4.4 The system shall calculate Total Sale Amount … 4.0 Outputs ... 4.3 The system shall print a receipt for each Sale ... Use Case In this lecture we will discuss the importance of good requirements. The Importance of Requirements Requirements Definition Let’s talk about some of the key reasons why requirements are so important.
 
First, the requirements phase in a project can be a major source of defects that get introduced into the project.
 
Second, the requirements are used as input to many of the subsequent project work phases.
 
And, third, requirements errors can be costly and time-consuming to fix…and contribute significantly to a project’s rework costs.
 
Let’s look into each of these in more detail.
 Why Requirements Are Important The requirements phase in a project can be a significant source of defects. The requirements for a project are used as input to many of the project life cycle work processes. Requirements defects contribute significantly to the cost of project rework. The requirements phase can be a significant source of project errors. More than half of all errors introduced during the course of a project can be introduced in the requirements phase.
 
That’s pretty significant. And…I can tell you from my own experience that I see levels of requirements errors in client projects that are consistent with the statistics indicated on the cited references.

If an organization can improve the requirements process so that these error levels are reduced, there are many cost and schedule benefits to be had.
 Requirements As a Source of Defects J. Robertson, S. Robertson, Requirements-Led Project Management, Addison-Wesley, 2004 W. Perry, A Structured Approach to Systems Testing, QED Press, 1983 60 % 60-67% Percentage of Defects Introduced During Requirements Phase Another reason requirements are so important is that the requirements are used as input to many of the subsequent project work phases.
 
For example, requirements are used as a direct input to the design process and the test planning process. If the requirements are defective it can have a negative impact on the design and test efforts as well.
 
And…there can be many other processes that use the requirements as input.
 Other Project Phases Are Dependent On Requirements Requirements errors can be costly and time-consuming to fix…and there are a number of industry statistics that nicely illustrate the impact of bad requirements in this regard.


A number of industry studies have measured the percentage of rework effort on projects to range from 40 percent to more than 50 percent of total project effort. 
 
This chart shows a rework statistic that falls near the midpoint of that range…45 percent of total project effort. This indicates that for every 1,000 total person-hours of effort, about 450 person-hours was spent on rework. That’s a pretty significant cost impact. 

Here’s another industry statistic. About 80 percent of rework effort is spent fixing problems that occurred as a result of bad requirements. If we apply this to the first rework statistics…then 80 percent of 45 percent is 36 percent…so, 36 percent of rework effort on a typical project is spent reworking bad requirements. And that’s a very significant contribution to project cost…and project schedule.

Imagine if half of the project rework could be eliminated…cost is directly reduced and schedule will also be shortened. In a later course module on software quality, we’ll talk more about how bad requirements can influence project cost and schedule. Bad Requirements Can Be Costly 45% of typical project effort is spent on rework 36% of typical project effort is spent reworking bad requirements If we look at the types of requirements defects that introduced into projects, the results are quite interesting. 80 percent of the requirements defects fall into two categories…incorrect requirements information and omitted requirements information.

So…if we want to reduce the number of requirements defects…one strategy to take is to look at the drivers that cause these two types of errors. So…let’s see how we might do that. Major Types of Requirements Defects Incorrect Information 49% Omitted Requirements 31% Other 20% Adapted from I. Hooks & K. Farry, Customer-Centered Products: Creating Successful Products Through Smart Requirements Management, American Management Association, New York, 2001 Let’s talk a bit about some of the things that go into making good requirements. In other words, characteristics that are associated with good requirements. I’m going to limit my discussion to the four characteristics that you see here. Good requirements are correct, complete, testable, and unambiguous. I could have added quite a few more characteristics, but these will take us where we need to go in terms of understanding some key things that can be done to help mitigate some major requirements problems.

Note that I put correctness and completeness at the top of the list. That’s because 80 percent of requirements problems fall into these two categories as we saw in an earlier slide. Note also that these characteristics are also correlated with each other to a certain extent. For example, an incomplete requirement is also incorrect. A requirement that is untestable may be that way because the requirement is ambiguous, or because the requirement is incomplete, and so forth.

Let’s start with correctness. It’s pretty obvious that a requirement should contain correct information…so why is incorrectness at the top of the major defects list? Let’s look at what may cause a requirement to be incorrect.

One thing that can drive correctness is the identification collaboration effort with key project stakeholders. If the key project stakeholders are not identified, or if they are not collaborated with…then we risk getting incorrect information. Solution…make sure that our work process includes a stakeholder identification step that identifies all project stakeholders. A simple model for this will be illustrated in the next lecture.

How about completeness? Well, there are two types of completeness…what I call micro-level completeness and macro-level completeness. Micro-level completeness is applied to each individual requirement. Is that requirement completely defined? That’s not usually a problem for non-functional requirements, but it’s a bigger problem for functional requirements. So…how can this be mitigated? Remember the five-part functional requirements model I illustrated in an earlier lecture…each functional requirement must have a definition, and may have inputs, outputs, business rules, and constraints.

The second type of completeness is macro-level completeness. Macro-level completeness is applied to the entire set of requirements for a project. At that level, the requirements are complete if all the needed requirements for the project have been identified…and that’s often hard to assess. So, how can we mitigate this problem? To help ensure that all the non-functional requirements have been identified we can use a checklist of possible non-functional requirements…and simply go through each potential non-functional requirement and determine if it is applicable to our project. Incomplete non-functional requirements are often the result of oversight…so a checklist is a simple tool to deal with this. For assessing the completeness of functional requirements at the macro level, there are two key things that can help: one…using an iterative life cycle, and two…using use cases to capture the project’s functional requirements. You’ll learn about use cases a bit later on in this course module.

Let me discuss the next two characteristics together since they’re highly correlated. A good requirement is unambiguous, meaning it has only one interpretation. A requirement that has multiple interpretations can cause incorrectness as a project progresses. For example, a software engineer may interpret a requirement in a particular way and base their design and coding assumptions on that interpretation. But, the engineer’s interpretation may not match with the business stakeholder interpretation, and it’s that interpretation that sets expectations. Ambiguity can be mitigated by choosing an effective documentation technique and by applying the testability test. 

A requirement is testable if we can answer “yes” to the following questions: one…can we construct a set of tests to demonstrate whether this requirement has been implemented (or not) in the software product? And, two…whether it has been implemented correctly and completely. If the answer to either question is “no”, then the requirement is not testable…and…it may be because it is ambiguous. Let me take an example. Suppose a requirement stated that “all aspects of product performance shall be optimized.” That fails the testability test…because it is ambiguous. You can also see how design and coding decisions made by a software engineer’s interpretation of that requirement can lead to incorrectness. Characteristics Of Good Requirements 